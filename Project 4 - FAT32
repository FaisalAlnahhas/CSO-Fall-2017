////Faisal Alnahhas
//UT Arlington - Fall 2017
//OS - Project 2 Writing a Shell
//  msh.c
//
//
//  Created by Faisal Alnahhas on 10/8/17.
//

// The MIT License (MIT)
//
// Copyright (c) 2016, 2017 Trevor Bakker
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#define _GNU_SOURCE

#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <stdint.h>

#define WHITESPACE " \t\n"      // We want to split our command line up into tokens
// so we need to define what delimits our tokens.
// In this case  white space
// will separate the tokens on our command line

#define MAX_COMMAND_SIZE 255    // The maximum command-line size

//Changing it to 10 per requirement of project
#define MAX_NUM_ARGUMENTS 10     // Mav shell only supports five arguments


short BPB_BytesPerSec;
unsigned char BPB_SecPerClus;
int BPB_FATSz32;
unsigned char BPB_NumFATS;
short BPB_RsvdSecCnt;

struct __attribute__((__packed__)) DirectoryEntry {
    char        DIR_Name[11];
    uint8_t     DIR_Attr;
    uint8_t     Uunsed1[8];
    uint16_t    DIR_FirstClusterHigh;
    uint8_t     Uunsed2[4];
    uint16_t    DIR_FirstClusterLow;
    uint32_t    DIR_FileSize;
};
struct DirectoryEntry dir[16];

struct bpb_info {
    char        BS_OEMName[8];
    int8_t      BPB_SecPerClus;
    int16_t     BPB_RsvdSecCnt;
    int8_t      BPB_NumFATS;
    int16_t     BPB_RootEntCnt;
    char        BS_VolLab[11];
    int32_t     BPB_FATSz32;
    int32_t     BPB_RootClus;
    int32_t     RootDirSectors;
    int32_t     FirstDataSector;
    int32_t     FirstSectorofcluster;
    int16_t     BPB_BytesPerSec;
    
};
struct bpb_info Info;

//for any path passed to cd, insert / at beginning and concatenate it with the rest of the path
//obtained using getcwd, then use chdir to change directory to the full path
int cd(char *path)
{
    char cwd[255];
    getcwd(cwd, sizeof(cwd));
    strcat(cwd, "/");
    strcat(cwd, path);
    chdir(cwd);
    return 0;
}

FILE *file_open(char *f)
{
    FILE *fo = fopen(f, "r");
    if (fo == NULL)
    {
        printf("Error: File system image not found\n");
        return fo;
    }
    fseek(fo, 11, SEEK_SET);
    
    
    /*
    FILE *fo = fopen(f, "r");
    
    if (fo == NULL) printf("Error: File system image not found\n");
    
    else
    {
        while (!feof(fo))
        {
            char chars = fgetc(fo);
            if (feof(fo)) break;
            printf("%c", chars);
        }
        fclose(fo);
    } */
    return fo;
    
}

void file_close()
{
    FILE *fc;
    fclose(fc);
}

/*void get_info(FILE *fc)
{
    int n = 2;
    int bytes = 512;
    int sectors = bytes * n;
    int clusters = sectors * n;
    int i;
    int val_BPS;
    int val_SPC;
    int val_RSC;
    int val_NF;
    int val_F32;
    
    fseek(fc, 11, SEEK_SET);//BytesPerSec
    fread(&val_BPS, 2, 1, fc);
    printf("BPB_BytePerSec: %d\n", val_BPS);
    fseek(fc, 13, SEEK_SET);//SecPerClus
    fread(&val_SPC, 1, 1, fc);
    printf("BPB_SecPerClus: %d\n", val_SPC);
    fseek(fc, 14, SEEK_SET);//RsvdSecCnt
    fread(&val_RSC, 2, 1, fc);
    printf("BPB_RsvdSecCnt: %d\n", val_RSC);
    fseek(fc, 16, SEEK_SET);//NumFats
    fread(&val_NF, 1, 1, fc);
    printf("BPB_NumFATS: %d\n", val_NF);
    fseek(fc, Info.BPB_NumFATS, SEEK_SET);//FATSz32
    fread(&val_F32, 2, 1, fc);
    printf("BPB_FATSz32: %d\n", val_F32);
    
    long root_dir = (Info->BPB_NumFATS * Info->BPB_FATSz32 * Info->BPB_BytesPerSec) + (Info->BPB_RsvdSecCnt * Info->BPB_BytesPerSec);
    fseek(root_dir, 11, SEEK_SET);
    
    for(i=0; i<16; i++)
    {
        fread(dir, sizeof(dir), 32, fc);
        printf("%d\n", i);
        printf("%02X\n", i);
    }
    
} */

void stats(FILE *fc, char *passed_file)
{
    int i;
    char *name = passed_file;
    long root_dir = (BPB_NumFATS * BPB_FATSz32 * BPB_BytesPerSec) + (BPB_RsvdSecCnt * BPB_BytesPerSec);
    fseek(fc, root_dir, SEEK_SET);
    for(i=0; i<16; i++)
    {
        memset(&dir[i].DIR_Name, 0, 11);
        fread(&dir[i], 32, 1 , fc);
       // memset(name, 0 , 12);
       // strncpy(&name[0], dir[i].DIR_Name, 11);
        
    }
    
    for(i=0;i<16;i++)
    {
        if(dir[i].DIR_Attr == 0x10 || dir[i].DIR_Attr == 0x20) printf("Filename: %s\n", dir[i].DIR_Name);
    }

    
    
    
    
    
    /*int val_attr;
    fseek(fc, 11, SEEK_SET);
    fread(&val_attr,1,1,fc);
    printf("DIR_ATTR: %d\n", val_attr); */
    
}


int main()
{
    int open_image = 0;
    int close_image = 0;
    int command_index = 0;
    char * cmd_str = (char*) malloc( MAX_COMMAND_SIZE );
    //dynamically create a new copy of cmd_str to avoid collision of memory for the pointers
    char * cmd_str_copy = (char*) malloc( MAX_COMMAND_SIZE );
    
    char *commands[15]; //array for storing the commands entered
    
    char *pids[255]; //array for storing the pids
    int *pid_index; //a pointer to the index so we can use it later to grab the value of the pid
    int pid_index_copy = 0; //to avoid memory collision use a copy of pid_index
    
    FILE *fopened;
    
    
    
    
    
    while( 1 )
    {
        // Print out the msh prompt
    top:        printf ("mfs> ");
        
        // Read the command from the commandline.  The
        // maximum command that will be read is MAX_COMMAND_SIZE
        // This while command will wait here until the user
        // inputs something since fgets returns NULL when there
        // is no input
        
        //no need to use while to wait for user input because we're okay with empty input
        fgets (cmd_str, MAX_COMMAND_SIZE, stdin);
        
        if (!strcmp(cmd_str, "\n"))
        {
            goto top; //if user just hits enter with typing anything go back to prompting mfs>
        }
        
        /* Parse input */
        char *token[MAX_NUM_ARGUMENTS];
        
        int   token_count = 0;
        int token_index = 0;
        int status;
        
        // Pointer to point to the token
        // parsed by strsep
        char *arg_ptr;
        
        char *working_str  = strdup( cmd_str );
        
        // we are going to move the working_str pointer to
        // keep track of its original value so we can deallocate
        // the correct amount at the end
        char *working_root = working_str;
        
        // Tokenize the input stringswith whitespace used as the delimiter
        while ( ( (arg_ptr = strsep(&working_str, WHITESPACE ) ) != NULL) &&
               (token_count<MAX_NUM_ARGUMENTS))
        {
            token[token_count] = strndup( arg_ptr, MAX_COMMAND_SIZE );
            if( strlen( token[token_count] ) == 0 )
            {
                token[token_count] = NULL;
            }
            token_count++;
        }
        
        if((!strcmp(token[token_index], "exit")) || (!strcmp(token[token_index], "quit")))
        {
            status = 0;
            exit(status);
        }
        
        else if(open_image==0 && close_image==1)
        {
            printf("Error: File system image must be opened first.\n");
        }
        
        else if(open_image == 0)
        {
            if (!strcmp(token[token_index], "open"))
            {
                printf("Image file opened.\n");
                fopened = file_open(token[token_index + 1]);
                open_image += 1;
                close_image = 0;
                fseek(fopened, 11, SEEK_SET);
                fread(&BPB_BytesPerSec, 2, 1, fopened);
                
                fseek(fopened, 13, SEEK_SET);//SecPerClus
                fread(&BPB_SecPerClus, 1, 1, fopened);
                
                
                fseek(fopened, 36, SEEK_SET);//FATSz32
                fread(&BPB_FATSz32, 4, 1, fopened);
                
                
                fseek(fopened, 16, SEEK_SET);//NumFATs
                fread(&BPB_NumFATS, 2, 1, fopened);
                
                
                fseek(fopened, 14, SEEK_SET);//Rsvd
                fread(&BPB_RsvdSecCnt, 2, 1, fopened);
            }
            
            
            else if (!strcmp(token[token_index], "close"))
            {
                printf("Error: File system not open.\n");
            }
            
            
        }
        
        
        else if((open_image == 1) && (close_image == 0))
        {
            //calling the cd function introduced above. cd is the 0th index in tokenized input and the
            //desired directory is the 1st element in the tokenized input so we switch to token_index+1
            if (!strcmp(token[token_index], "cd"))
            {
                cd(token[token_index + 1]);
            }
            
            else if (!strcmp(token[token_index], "open"))
            {
                printf("Error: File image already open\n");
            }
            else if (!strcmp(token[token_index], "info"))
            {
                printf("information: \n");
                
                printf("BPB_BytesPerSec: %d\n", BPB_BytesPerSec);
                
                printf("BPB_SecPerClus: %d\n", BPB_SecPerClus);
               
                printf("BPB_FATSz32: %d\n", BPB_FATSz32);
                
                printf("BPB_NumFATS: %d\n", BPB_NumFATS);
                
                printf("BPB_RsvdSecCnt: %d\n", BPB_RsvdSecCnt);
                
            }
            else if (!strcmp(token[token_index], "stat"))
            {
                int i;
                char *name = token[token_index + 1];
                int root_dir = (BPB_NumFATS * BPB_FATSz32 * BPB_BytesPerSec) + (BPB_RsvdSecCnt * BPB_BytesPerSec);
                fseek(fopened, root_dir, SEEK_SET);
                printf("root_dir: %d\n", root_dir);
                for(i=0; i<16; i++)
                {
                    memset(&dir[i].DIR_Name, 0, 11);
                    fread(&dir[i], 32, 1 , fopened);

                    
                }
                
                for(i=0;i<16;i++)
                {
                    if(dir[i].DIR_Attr == 0x10 || dir[i].DIR_Attr == 0x20)
                        if ((!strcmp(name, dir[i].DIR_Name)))
                    {
                        memset(name, 0 , 12);
                        strncpy(&name[0], dir[i].DIR_Name, 11);
                        printf("Filename: %s\n", name);
                        printf("First Cluster: %d\n", dir[i].DIR_FirstClusterLow);
                        printf("File Size: %d\n", dir[i].DIR_FileSize);
                        printf("\n");
                    }
                }
                

            }
            else if (!strcmp(token[token_index], "close"))
            {
                file_close();
                printf("Closed.\n");
                open_image -= 1;
                close_image += 1;
            }
            
        }
        else
        {
            printf("Bananas.\n");
        }
        
       
        free( working_root );
        
    }
    return 0;
}


